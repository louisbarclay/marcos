import fs from "fs";
import path from "path";
import yaml from "js-yaml";

const dataDir = path.join(process.cwd(), "data", "systems");
const outputFile = path.join(process.cwd(), "lib", "generated-data.ts");

interface SystemInfo {
  id: string;
  name: string;
}

interface LineInfo {
  id: string;
  name: string;
}

interface StationData {
  station_name?: string;
  status?: string;
  platforms: {
    [line: string]: {
      [direction: string]: {
        door_side?: string;
        exits?: {
          [exitName: string]: string | number;
        };
      };
    };
  };
}

function generateDataModule() {
  // Read systems.yaml
  const systemsYamlPath = path.join(process.cwd(), "data", "systems", "systems.yaml");
  let systems: SystemInfo[] = [];
  
  if (fs.existsSync(systemsYamlPath)) {
    const systemsData = yaml.load(fs.readFileSync(systemsYamlPath, "utf8")) as SystemInfo[];
    if (Array.isArray(systemsData)) {
      systems = systemsData;
    }
  }
  
  // Fallback: read from directories
  if (systems.length === 0) {
    const systemsDirs = fs.readdirSync(dataDir, { withFileTypes: true });
    systems = systemsDirs
      .filter((dirent) => dirent.isDirectory() && dirent.name !== "systems")
      .map((dirent) => ({
        id: dirent.name,
        name: dirent.name.replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()),
      }));
  }

  const systemsData: Record<string, any> = {};
  const linesData: Record<string, LineInfo[]> = {};
  const stationsData: Record<string, Record<string, StationData>> = {};

  // Process each system
  for (const system of systems) {
    const systemPath = path.join(dataDir, system.id);
    
    // Read lines
    const linesPath = path.join(systemPath, "lines.yaml");
    if (fs.existsSync(linesPath)) {
      const linesFile = yaml.load(fs.readFileSync(linesPath, "utf8")) as LineInfo[] | string[];
      if (Array.isArray(linesFile)) {
        if (linesFile.length > 0 && typeof linesFile[0] === "object" && "id" in linesFile[0]) {
          linesData[system.id] = linesFile as LineInfo[];
        } else {
          linesData[system.id] = (linesFile as string[]).map((line) => ({
            id: String(line),
            name: String(line),
          }));
        }
      }
    }

    // Read stations
    const stationsPath = path.join(systemPath, "stations");
    if (fs.existsSync(stationsPath)) {
      stationsData[system.id] = {};
      const stationFiles = fs.readdirSync(stationsPath);
      
      for (const file of stationFiles) {
        if (file.endsWith(".yaml")) {
          const stationId = file.replace(".yaml", "");
          const stationPath = path.join(stationsPath, file);
          try {
            const fileContent = fs.readFileSync(stationPath, "utf8").trim();
            if (!fileContent) {
              console.warn(`Skipping empty station file ${stationId} in ${system.id}`);
              continue;
            }
            
            const stationData = yaml.load(fileContent) as StationData | null;
            
            // Skip if stationData is null/undefined or doesn't have platforms
            if (!stationData || typeof stationData !== 'object' || !stationData.platforms) {
              console.warn(`Skipping station ${stationId} in ${system.id}: missing or invalid platforms`);
              continue;
            }
            
            // Clean up null values in platforms (empty YAML entries become null)
            Object.keys(stationData.platforms).forEach((lineId) => {
              const linePlatforms = stationData.platforms[lineId];
              if (!linePlatforms || typeof linePlatforms !== 'object') {
                stationData.platforms[lineId] = {};
                return;
              }
              Object.keys(linePlatforms).forEach((direction) => {
                const directionData = linePlatforms[direction];
                if (directionData === null || directionData === undefined) {
                  linePlatforms[direction] = {};
                } else if (typeof directionData === 'object') {
                  // Remove null exits (JSON.stringify will omit undefined)
                  if (directionData.exits === null) {
                    delete directionData.exits;
                  }
                }
              });
            });
            
            stationsData[system.id][stationId] = stationData;
          } catch (error) {
            console.error(`Error loading station ${stationId} in ${system.id}:`, error);
          }
        }
      }
    }
  }

  // Generate TypeScript file
  const output = `// This file is auto-generated by scripts/generate-data.ts
// Do not edit manually - run 'npm run generate-data' to regenerate

export interface SystemInfo {
  id: string;
  name: string;
}

export interface LineInfo {
  id: string;
  name: string;
}

export interface StationData {
  station_name?: string;
  status?: string;
  platforms: {
    [line: string]: {
      [direction: string]: {
        door_side?: string;
        exits?: {
          [exitName: string]: string | number;
        };
      };
    };
  };
}

export const systems: SystemInfo[] = ${JSON.stringify(systems, null, 2)};

export const lines: Record<string, LineInfo[]> = ${JSON.stringify(linesData, null, 2)};

export const stations: Record<string, Record<string, StationData>> = ${JSON.stringify(stationsData, (key, value) => value === null ? undefined : value, 2)};
`;

  fs.writeFileSync(outputFile, output, "utf8");
  console.log(`âœ“ Generated data module at ${outputFile}`);
  console.log(`  - ${systems.length} systems`);
  console.log(`  - ${Object.keys(linesData).length} systems with lines`);
  console.log(`  - ${Object.values(stationsData).reduce((sum, sys) => sum + Object.keys(sys).length, 0)} stations`);
}

generateDataModule();

